@using System.Linq
@using System.Globalization
@using Microsoft.AspNetCore.Components
@using SettlersOfIdlestan.Model.IslandMap
@using SettlersOfIdlestan.Model.HexGrid
@using SettlersOfIdlestan.Model.Civilization
@using SettlersOfIdlestan.Model.City
@using SettlersOfIdlestan.Model.Road
@using SettlersOfIdlestan.Controller
@using SettlersOfIdlestan.Model.Game
@using System.Diagnostics

@if (Map is null)
{
    <div class="map-placeholder">Aucune carte fournie</div>
}
else
{
    <svg @ref="svgRef" width="@SvgWidth" height="@SvgHeight" viewBox="@ViewBox" style="background:#eef2f5">
        @foreach (var tile in Map.Tiles.Values)
        {
            var center = AxialToPixel(tile.Coord);
            var points = GetHexPoints(center.x, center.y);
            // Determine if player can harvest this tile (has a city adjacent and tile has resource)
            Civilization? player = Civilizations?.FirstOrDefault(c => c != null && c.Index == 0) ?? Civilizations?.FirstOrDefault();
            var canHarvest = false;
            if (player != null && tile.Resource.HasValue)
            {
                canHarvest = player.Cities.Any(city => city.Position.IsAdjacentTo(tile.Coord));
            }

            var centerX = center.x.ToString(CultureInfo.InvariantCulture);
            var centerY = center.y.ToString(CultureInfo.InvariantCulture);

            if (canHarvest)
            {
                <polygon points="@points" fill="@TerrainColor(tile.TerrainType)" stroke="#333" stroke-width="1" style="cursor:pointer;pointer-events:auto" @onclick="() => OnClickHex(tile.Coord)"></polygon>
            }
            else
            {
                <polygon points="@points" fill="@TerrainColor(tile.TerrainType)" stroke="#333" stroke-width="1" style="pointer-events:auto"></polygon>
            }

            @* Show production number as before *@
            @if (tile.ProductionNumber.HasValue)
            {
                @((MarkupString)RenderProductionSvg(tile))
            }

            @* Show harvest cooldown overlay when applicable *@
            if (canHarvest && State != null && gameClock != null)
            {
                double remaining = 0.0;
                var civMap = State.HarvestLastTimesByCivilization;
                if (civMap.TryGetValue(player!.Index, out var perHex) && perHex.TryGetValue(tile.Coord, out var last))
                {
                    var elapsed = gameClock.CurrentTime - last;
                    if (elapsed < harvestCooldown)
                    {
                        remaining = (harvestCooldown - elapsed).TotalSeconds;
                    }
                }

                if (remaining > 0)
                {
                    var cooldownSvg = $"<text x=\"{centerX}\" y=\"{centerY}\" font-size=\"12\" text-anchor=\"middle\" fill=\"#900\" pointer-events=\"none\">{remaining.ToString("0.0", CultureInfo.InvariantCulture)}s</text>";
                    @((MarkupString)cooldownSvg)
                }
            }
        }
        @* Render cities from provided civilizations *@
        @if (Civilizations != null)
        {
            var spriteSize = HexSize * 0.8;
            var roadStrokeWidth = Math.Max(8.0, HexSize * 0.18);
            var civColors = new[] { "#e6194b", "#3cb44b", "#4363d8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#bcf60c" };
            foreach (var civ in Civilizations)
            {
                var color = civColors[(civ.Index >= 0 ? civ.Index : 0) % civColors.Length];

                foreach (var city in civ.Cities ?? Enumerable.Empty<City>())
                {
                    try
                    {
                        var p = VertexToPixel(city.Position);
                        var imgX = (p.x - spriteSize / 2).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var imgY = (p.y - spriteSize / 2).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var w = spriteSize.ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var h = spriteSize.ToString(System.Globalization.CultureInfo.InvariantCulture);
                        // choose sprite by civilization index if available, fallback to generic city.png
                        var spritePath = $"assets/sprites/city-outpost.svg";
                        // use generic if indexed sprite not found at runtime; we still reference it here and let static server handle missing files
                        <image href="@spritePath" x="@imgX" y="@imgY" width="@w" height="@h" style="pointer-events:none" />
                    }
                    catch
                    {
                        // ignore rendering errors per-city
                    }
                }

                // Built roads: draw a solid line per road using civilization color
                foreach (var road in civ.Roads ?? Enumerable.Empty<Road>())
                {
                    try
                    {
                        var verts = road.Position.GetVertices();
                        var p1 = VertexToPixel(verts[0]);
                        var p2 = VertexToPixel(verts[1]);
                        var x1 = (p1.x).ToString(CultureInfo.InvariantCulture);
                        var y1 = (p1.y).ToString(CultureInfo.InvariantCulture);
                        var x2 = (p2.x).ToString(CultureInfo.InvariantCulture);
                        var y2 = (p2.y).ToString(CultureInfo.InvariantCulture);
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="@color" stroke-width="@roadStrokeWidth" stroke-linecap="round" style="pointer-events:none" />
                    }
                    catch
                    {
                        // ignore rendering errors per-road
                    }
                }
            }
            // Buildable roads: use RoadController to obtain buildable edges for the player (prefer civ index 0)
            Civilization? player = Civilizations.FirstOrDefault(c => c != null && c.Index == 0) ?? Civilizations.FirstOrDefault();
            if (player != null && Map != null)
            {
                var buildableRoads = Controller!.RoadController.GetBuildableRoads(player.Index);
                var dashColor = "#333";

                foreach (var road in buildableRoads)
                {
                    try
                    {
                        var verts = road.Position.GetVertices();
                        var p1 = VertexToPixel(verts[0]);
                        var p2 = VertexToPixel(verts[1]);
                        var x1 = (p1.x).ToString(CultureInfo.InvariantCulture);
                        var y1 = (p1.y).ToString(CultureInfo.InvariantCulture);
                        var x2 = (p2.x).ToString(CultureInfo.InvariantCulture);
                        var y2 = (p2.y).ToString(CultureInfo.InvariantCulture);
                        var isHovered = hoveredEdge != null && hoveredEdge.Equals(road.Position);
                        var lineColor = isHovered ? "#ffd54f" : dashColor;
                        var lineWidth = isHovered ? roadStrokeWidth * 1.6 : roadStrokeWidth;
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="@lineColor" stroke-width="@lineWidth" stroke-linecap="round" stroke-dasharray="3" stroke-opacity="0.9" style="cursor:pointer" @onmouseover="(()=>OnHoverBuildableEdge(road.Position))" @onmouseout="OnLeaveBuildableEdge" @onclick="(()=>OnClickBuildableRoad(road))" />
                    }
                    catch
                    {
                        // ignore per-road errors
                    }
                }
            }
        }
	</svg>
    @if (!string.IsNullOrEmpty(buildMessage))
    {
        <div class="build-message" style="margin-top:6px;color:#900">@buildMessage</div>
    }
}

@code {
    [Parameter] public IslandState? State { get; set; }
    [Parameter] public MainGameController? Controller { get; set; }
    [Parameter] public double HexSize { get; set; } = 36;

    private IslandMap? Map { get { return State?.Map; } }
    private List<SettlersOfIdlestan.Model.Civilization.Civilization>? Civilizations { get { return State?.Civilizations; } }
    private SettlersOfIdlestan.Model.Game.GameClock gameClock { get { return Controller!.Clock!; } }

    // hovered edge for buildable highlighting
    private SettlersOfIdlestan.Model.HexGrid.Edge? hoveredEdge;
    private string? buildMessage;
    // small local islandState and clock to query cooldowns
    private readonly TimeSpan harvestCooldown = TimeSpan.FromSeconds(2);

    private ElementReference svgRef;

    // Bounds used to set the SVG viewBox
    private double MinX = 0, MinY = 0, MaxX = 0, MaxY = 0;

    private double SvgWidth => (MaxX - MinX) + HexSize * 2;
    private double SvgHeight => (MaxY - MinY) + HexSize * 2;
    private string ViewBox => $"{(MinX - HexSize).ToString(CultureInfo.InvariantCulture)} {(MinY - HexSize).ToString(CultureInfo.InvariantCulture)} {SvgWidth.ToString(CultureInfo.InvariantCulture)} {SvgHeight.ToString(CultureInfo.InvariantCulture)}";

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (Map is null) return;
        ComputeBounds();
    }

    private void ComputeBounds()
    {
        bool first = true;
        if (Map is null) {            
            MinX = 0;
            MinY = 0;
            MaxX = 0;
            MaxY = 0;
        }
        else {
            foreach (var t in Map.Tiles.Values)
            {
                var p = AxialToPixel(t.Coord);
                if (first)
                {
                    MinX = MaxX = p.x;
                    MinY = MaxY = p.y;
                    first = false;
                }
                else
                {
                    MinX = Math.Min(MinX, p.x);
                    MinY = Math.Min(MinY, p.y);
                    MaxX = Math.Max(MaxX, p.x);
                    MaxY = Math.Max(MaxY, p.y);
                }
            }
        }
    }

    // Axial -> pixel (pointy-top hex layout)
    private (double x, double y) AxialToPixel(HexCoord c)
    {
        var size = HexSize;
        var x = size * Math.Sqrt(3) * (c.Q + c.R / 2.0);
        var y = size * 3.0 / 2.0 * c.R;
        return (x, y);
    }

    private string GetHexPoints(double cx, double cy)
    {
        var pts = Enumerable.Range(0, 6).Select(i =>
        {
            // pointy-top: start angle -30°
            var angle = Math.PI / 180.0 * (60 * i - 30);
            var x = cx + HexSize * Math.Cos(angle);
            var y = cy + HexSize * Math.Sin(angle);
            return $"{x.ToString(CultureInfo.InvariantCulture)},{y.ToString(CultureInfo.InvariantCulture)}";
        });
        return string.Join(" ", pts);
    }

    private string TerrainColor(TerrainType t) => t switch
    {
        TerrainType.Forest => "#2e8b57",
        TerrainType.Hill => "#c37b4a",
        TerrainType.Pasture => "#9acd32",
        TerrainType.Field => "#f4d35e",
        TerrainType.Mountain => "#8b8f8f",
        TerrainType.Desert => "#f0e1a1",
        TerrainType.Water => "#6fb3ff",
        _ => "#cccccc"
    };

    private string RenderProductionSvg(HexTile tile)
    {
        if (tile.ProductionNumber is null) return string.Empty;

        var center = AxialToPixel(tile.Coord);
        var x = center.x.ToString(CultureInfo.InvariantCulture);
        var y = (center.y + HexSize * 0.1).ToString(CultureInfo.InvariantCulture);
        return $"<text x=\"{x}\" y=\"{y}\" font-size=\"12\" text-anchor=\"middle\" fill=\"#111\">{tile.ProductionNumber.Value}</text>";
    }

    private (double x, double y) VertexToPixel(Vertex v)
    {
        // average of the three adjacent hex centers
        var h1 = AxialToPixel(v.Hex1);
        var h2 = AxialToPixel(v.Hex2);
        var h3 = AxialToPixel(v.Hex3);
        return ((h1.x + h2.x + h3.x) / 3.0, (h1.y + h2.y + h3.y) / 3.0);
    }

    private void OnHoverBuildableEdge(SettlersOfIdlestan.Model.HexGrid.Edge edge)
    {
        hoveredEdge = edge;
        StateHasChanged();
    }

    private void OnLeaveBuildableEdge()
    {
        hoveredEdge = null;
        StateHasChanged();
    }

    private void OnClickBuildableRoad(SettlersOfIdlestan.Model.Road.Road road)
    {
        try
        {
            Controller!.RoadController.BuildRoad(road.CivilizationIndex, road.Position);
            buildMessage = "Route construite";
        }
        catch (Exception ex)
        {
            buildMessage = ex.Message;
        }
        StateHasChanged();
    }

    private void OnClickHex(HexCoord coord)
    {
        try
        {
            if (Map == null || Civilizations == null) return;
            // perform a manual harvest for player (index 0)
            var success = Controller!.HarvestController.ManualHarvest(0, coord);
            buildMessage = success ? "Récolte réussie" : "Récolte en cooldown ou impossible";
        }
        catch (Exception ex)
        {
            buildMessage = ex.Message;
        }
        StateHasChanged();
    }
}

