@using System.Linq
@using System.Globalization
@using SettlersOfIdlestan.Model.IslandMap
@using SettlersOfIdlestan.Model.HexGrid
@using SettlersOfIdlestan.Model.Civilization
@using SettlersOfIdlestan.Model.City
@using SettlersOfIdlestan.Model.Road
@using SettlersOfIdlestan.Controller
@using SettlersOfIdlestan.Model.Game
@inject Microsoft.Extensions.Logging.ILogger<IslandMapView>? Logger

@if (Map is null)
{
    <div class="map-placeholder">Aucune carte fournie</div>
}
else
{
    <svg @ref="svgRef" width="@SvgWidth" height="@SvgHeight" viewBox="@ViewBox" style="background:#eef2f5;user-select:none;-webkit-user-select:none" @onclick="OnMapBackgroundClick">
        @* Background rect for deselection click - placed first so polygons render on top *@
        <rect x="@((MinX - HexSize).ToString(CultureInfo.InvariantCulture))" y="@((MinY - HexSize).ToString(CultureInfo.InvariantCulture))" width="@SvgWidth.ToString(CultureInfo.InvariantCulture)" height="@SvgHeight.ToString(CultureInfo.InvariantCulture)" fill="transparent" style="pointer-events:none" />
        @foreach (var tile in Map.Tiles.Values)
        {
            var center = AxialToPixel(tile.Coord);
            var points = GetHexPoints(center.x, center.y);
            // Determine if player can harvest this tile (has a city adjacent and tile has resource)
            Civilization? player = Civilizations?.FirstOrDefault(c => c != null && c.Index == 0) ?? Civilizations?.FirstOrDefault();
            var canHarvest = false;
            if (player != null && tile.Resource.HasValue)
            {
                canHarvest = player.Cities.Any(city => city.Position.IsAdjacentTo(tile.Coord));
            }

            var centerX = center.x.ToString(CultureInfo.InvariantCulture);
            var centerY = center.y.ToString(CultureInfo.InvariantCulture);

            if (canHarvest)
            {
                var clickCoord = tile.Coord;
                <polygon points="@points" fill="@TerrainColor(tile.TerrainType)" stroke="#333" stroke-width="1" style="cursor:pointer" @onclick="() => OnClickHex(clickCoord)" @onclick:stopPropagation="true"></polygon>
            }
            else
            {
                <polygon points="@points" fill="@TerrainColor(tile.TerrainType)" stroke="#333" stroke-width="1" style="pointer-events:auto"></polygon>
            }

            @* Show production number as before *@
            @if (tile.ProductionNumber.HasValue)
            {
                @((MarkupString)RenderProductionSvg(tile))
            }

            @* Show harvest cooldown overlay when applicable *@
            if (canHarvest && State != null && gameClock != null)
            {
                double remaining = 0.0;
                var civMap = State.HarvestLastTimesByCivilization;
                if (civMap.TryGetValue(player!.Index, out var perHex) && perHex.TryGetValue(tile.Coord, out var last))
                {
                    var elapsed = gameClock.CurrentTime - last;
                    if (elapsed < harvestCooldown)
                    {
                        remaining = (harvestCooldown - elapsed).TotalSeconds;
                    }
                }

                if (remaining > 0)
                {
                    var cooldownSvg = $"<text x=\"{centerX}\" y=\"{centerY}\" font-size=\"12\" text-anchor=\"middle\" fill=\"#900\" pointer-events=\"none\">{remaining.ToString("0.0", CultureInfo.InvariantCulture)}s</text>";
                    @((MarkupString)cooldownSvg)
                }
            }
        }
        @* Render roads first, then cities on top for proper z-ordering *@
        @if (Civilizations != null)
        {
            var spriteSize = HexSize * 0.8;
            // increase road stroke so roads are more visible at various zooms
            var roadStrokeWidth = Math.Max(4.0, HexSize * 0.15);
            var roadInnerWidth = roadStrokeWidth * 0.5;
            var civColors = new[] { "#e6194b", "#3cb44b", "#4363d8", "#f58231", "#911eb4", "#46f0f0", "#f032e6", "#bcf60c" };

            // Built roads per civilization
            foreach (var civ in Civilizations)
            {
                var color = civColors[(civ.Index >= 0 ? civ.Index : 0) % civColors.Length];
                foreach (var road in civ.Roads ?? Enumerable.Empty<Road>())
                {
                    try
                    {
                        var verts = road.Position.GetVertices();
                        var p1 = VertexToPixel(verts[0]);
                        var p2 = VertexToPixel(verts[1]);
                        var x1 = (p1.x).ToString(CultureInfo.InvariantCulture);
                        var y1 = (p1.y).ToString(CultureInfo.InvariantCulture);
                        var x2 = (p2.x).ToString(CultureInfo.InvariantCulture);
                        var y2 = (p2.y).ToString(CultureInfo.InvariantCulture);
                        // darker background stroke to improve contrast (mimic canvas: black line behind colored line)
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="#000" stroke-width="@(roadStrokeWidth.ToString(CultureInfo.InvariantCulture))" stroke-linecap="round" stroke-opacity="1" style="pointer-events:none" />
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="@color" stroke-width="@(roadInnerWidth.ToString(CultureInfo.InvariantCulture))" stroke-linecap="round" stroke-opacity="1" style="pointer-events:none" />
                    }
                    catch
                    {
                        // ignore rendering errors per-road
                    }
                }
            }

            // Buildable roads: use RoadController to obtain buildable edges for the player (prefer civ index 0)
            Civilization? player = Civilizations.FirstOrDefault(c => c != null && c.Index == 0) ?? Civilizations.FirstOrDefault();
            if (player != null && Map != null)
            {
                var buildableRoads = Controller!.RoadController.GetBuildableRoads(player.Index);
                // use player's civ color for buildable road suggestion to make it obvious who can build
                var dashColor = civColors[(player.Index >= 0 ? player.Index : 0) % civColors.Length];
                foreach (var road in buildableRoads)
                {
                    try
                    {
                        var verts = road.Position.GetVertices();
                        var p1 = VertexToPixel(verts[0]);
                        var p2 = VertexToPixel(verts[1]);
                        var x1 = (p1.x).ToString(CultureInfo.InvariantCulture);
                        var y1 = (p1.y).ToString(CultureInfo.InvariantCulture);
                        var x2 = (p2.x).ToString(CultureInfo.InvariantCulture);
                        var y2 = (p2.y).ToString(CultureInfo.InvariantCulture);
                        var isHovered = hoveredEdge != null && hoveredEdge.Equals(road.Position);
                        var lineColor = isHovered ? "#ffd54f" : dashColor;
                        var lineWidth = isHovered ? roadStrokeWidth * 1.2 : roadStrokeWidth;
                        var innerLineWidth = isHovered ? roadInnerWidth * 1.2 : roadInnerWidth;
                        // background to make dashed line readable (black line underneath)
                        // make background capture pointer events so hover/click area matches its width
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="#000" stroke-width="@(lineWidth.ToString(CultureInfo.InvariantCulture))" stroke-linecap="butt" stroke-opacity="@((isHovered?1:0.4).ToString(CultureInfo.InvariantCulture))" style="cursor:pointer" @onmouseover="(() => OnHoverBuildableEdge(road.Position))" @onmouseout="OnLeaveBuildableEdge" @onclick:stopPropagation="true" @onclick="(() => OnClickBuildableRoad(road))" />
                        <line x1="@x1" y1="@y1" x2="@x2" y2="@y2" stroke="@lineColor" stroke-width="@(innerLineWidth.ToString(CultureInfo.InvariantCulture))" stroke-linecap="butt" stroke-dasharray="6 6" stroke-opacity="1" style="pointer-events:none" />
                    }
                    catch
                    {
                        // ignore per-road errors
                    }
                }
                // Render buildable city vertices (small green dotted circles)
                try
                {
                    var buildableVerts = Controller!.CityBuilderController.GetBuildableVertices(player.Index);
                    foreach (var v in buildableVerts)
                    {
                        var p = VertexToPixel(v);
                        var cx = (p.x).ToString(CultureInfo.InvariantCulture);
                        var cy = (p.y).ToString(CultureInfo.InvariantCulture);
                        var isHoveredV = hoveredBuildableVertex != null && hoveredBuildableVertex.Equals(v);
                        var strokeW = (isHoveredV ? 3.0 : 2.0).ToString(CultureInfo.InvariantCulture);
                        <circle cx="@cx" cy="@cy" r="6" stroke="#2ecc71" stroke-width="@strokeW" stroke-dasharray="4 4" fill="#2ecc71" fill-opacity="0.03" style="cursor:pointer;pointer-events:auto" @onmouseover="(() => OnHoverBuildableVertex(v))" @onmouseout="OnLeaveBuildableVertex" @onclick:stopPropagation="true" @onclick="(() => OnClickBuildableVertex(v))" />
                    }
                }
                catch
                {
                    // ignore errors retrieving buildable vertices
                }
            }

            // Now render city sprites on top of roads so they are visible
            foreach (var civ in Civilizations)
            {
                foreach (var city in civ.Cities ?? Enumerable.Empty<City>())
                {
                    try
                    {
                        var p = VertexToPixel(city.Position);
                        var imgX = (p.x - spriteSize / 2).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var imgY = (p.y - spriteSize / 2).ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var w = spriteSize.ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var h = spriteSize.ToString(System.Globalization.CultureInfo.InvariantCulture);
                        var spritePath = $"assets/sprites/city-{city.LevelName}.svg";
                        <image href="@spritePath" x="@imgX" y="@imgY" width="@w" height="@h" style="cursor:pointer;pointer-events:auto" @onclick:stopPropagation="true" @onclick="(()=>CityClicked(city))" @onmouseover="(()=>OnHoverCity(city))" @onmouseout="OnLeaveCity" />
                    }
                    catch
                    {
                        // ignore rendering errors per-city
                    }
                }
            }

            // draw persistent selection highlight (below hover)
            if (SelectedCity != null)
            {
                try
                {
                    var sp = VertexToPixel(SelectedCity.Position);
                    var scx = sp.x.ToString(CultureInfo.InvariantCulture);
                    var scy = sp.y.ToString(CultureInfo.InvariantCulture);
                    var sr = (spriteSize / 2.0 + 4.0).ToString(CultureInfo.InvariantCulture);
                    <circle cx="@scx" cy="@scy" r="@sr" stroke="#ffd59a" stroke-width="3" fill="none" pointer-events="none" />
                }
                catch { }
            }

            // draw highlight for hovered city above everything
            if (hoveredCity != null)
            {
                try
                {
                    var hp = VertexToPixel(hoveredCity.Position);
                    var cx = hp.x.ToString(CultureInfo.InvariantCulture);
                    var cy = hp.y.ToString(CultureInfo.InvariantCulture);
                    var r = (spriteSize / 2.0 + 6.0).ToString(CultureInfo.InvariantCulture);
                    <circle cx="@cx" cy="@cy" r="@r" stroke="#ffd54f" stroke-width="3" fill="none" pointer-events="none" />
                }
                catch { }
            }
        }
	</svg>
    @if (!string.IsNullOrEmpty(buildMessage))
    {
        <div class="build-message" style="margin-top:6px;color:#900">@buildMessage</div>
    }
}

@code {
    [Parameter] public EventCallback<SettlersOfIdlestan.Model.City.City> OnCitySelected { get; set; }
    [Parameter] public SettlersOfIdlestan.Model.City.City? SelectedCity { get; set; }
    [Parameter] public IslandState? State { get; set; }
    [Parameter] public MainGameController? Controller { get; set; }
    [Parameter] public double HexSize { get; set; } = 36;

    private IslandMap? Map { get { return State?.Map; } }
    private List<SettlersOfIdlestan.Model.Civilization.Civilization>? Civilizations { get { return State?.Civilizations; } }
    private SettlersOfIdlestan.Model.Game.GameClock? gameClock { get { return Controller?.Clock; } }

    // hovered edge for buildable highlighting
    private SettlersOfIdlestan.Model.HexGrid.Edge? hoveredEdge;
    private SettlersOfIdlestan.Model.City.City? hoveredCity;
    private SettlersOfIdlestan.Model.HexGrid.Vertex? hoveredBuildableVertex;
    private string? buildMessage;
    // small local islandState and clock to query cooldowns
    private readonly TimeSpan harvestCooldown = TimeSpan.FromSeconds(2);

    private ElementReference svgRef;

    // Bounds used to set the SVG viewBox
    private double MinX = 0, MinY = 0, MaxX = 0, MaxY = 0;

    private double SvgWidth => (MaxX - MinX) + HexSize * 2;
    private double SvgHeight => (MaxY - MinY) + HexSize * 2;
    private string ViewBox => $"{(MinX - HexSize).ToString(CultureInfo.InvariantCulture)} {(MinY - HexSize).ToString(CultureInfo.InvariantCulture)} {SvgWidth.ToString(CultureInfo.InvariantCulture)} {SvgHeight.ToString(CultureInfo.InvariantCulture)}";

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (Map is null) return;
        ComputeBounds();
    }

    private void ComputeBounds()
    {
        bool first = true;
        if (Map is null) {            
            MinX = 0;
            MinY = 0;
            MaxX = 0;
            MaxY = 0;
        }
        else {
            foreach (var t in Map.Tiles.Values)
            {
                var p = AxialToPixel(t.Coord);
                if (first)
                {
                    MinX = MaxX = p.x;
                    MinY = MaxY = p.y;
                    first = false;
                }
                else
                {
                    MinX = Math.Min(MinX, p.x);
                    MinY = Math.Min(MinY, p.y);
                    MaxX = Math.Max(MaxX, p.x);
                    MaxY = Math.Max(MaxY, p.y);
                }
            }
        }
    }

    // Axial -> pixel (pointy-top hex layout)
    private (double x, double y) AxialToPixel(HexCoord c)
    {
        var size = HexSize;
        var x = size * Math.Sqrt(3) * (c.Q + c.R / 2.0);
        var y = size * 3.0 / 2.0 * c.R;
        return (x, y);
    }

    private string GetHexPoints(double cx, double cy)
    {
        var pts = Enumerable.Range(0, 6).Select(i =>
        {
            // pointy-top: start angle -30°
            var angle = Math.PI / 180.0 * (60 * i - 30);
            var x = cx + HexSize * Math.Cos(angle);
            var y = cy + HexSize * Math.Sin(angle);
            return $"{x.ToString(CultureInfo.InvariantCulture)},{y.ToString(CultureInfo.InvariantCulture)}";
        });
        return string.Join(" ", pts);
    }

    private string TerrainColor(TerrainType t) => t switch
    {
        TerrainType.Forest => "#2e8b57",
        TerrainType.Hill => "#c37b4a",
        TerrainType.Pasture => "#9acd32",
        TerrainType.Field => "#f4d35e",
        TerrainType.Mountain => "#8b8f8f",
        TerrainType.Desert => "#f0e1a1",
        TerrainType.Water => "#6fb3ff",
        _ => "#cccccc"
    };

    private string RenderProductionSvg(HexTile tile)
    {
        if (tile.ProductionNumber is null) return string.Empty;

        var center = AxialToPixel(tile.Coord);
        var x = center.x.ToString(CultureInfo.InvariantCulture);
        var y = (center.y + HexSize * 0.1).ToString(CultureInfo.InvariantCulture);
        // Ensure production text does not capture pointer events so underlying polygon receives clicks
        return $"<text x=\"{x}\" y=\"{y}\" font-size=\"12\" text-anchor=\"middle\" fill=\"#111\" pointer-events=\"none\">{tile.ProductionNumber.Value}</text>";
    }

    private (double x, double y) VertexToPixel(Vertex v)
    {
        // average of the three adjacent hex centers
        var h1 = AxialToPixel(v.Hex1);
        var h2 = AxialToPixel(v.Hex2);
        var h3 = AxialToPixel(v.Hex3);
        return ((h1.x + h2.x + h3.x) / 3.0, (h1.y + h2.y + h3.y) / 3.0);
    }

    private void OnHoverBuildableEdge(SettlersOfIdlestan.Model.HexGrid.Edge edge)
    {
        hoveredEdge = edge;
        StateHasChanged();
    }

    private void OnLeaveBuildableEdge()
    {
        hoveredEdge = null;
        StateHasChanged();
    }

    private void OnClickBuildableRoad(SettlersOfIdlestan.Model.Road.Road road)
    {
        try
        {
            Controller!.RoadController.BuildRoad(road.CivilizationIndex, road.Position);
            buildMessage = "Route construite";
        }
        catch (Exception ex)
        {
            buildMessage = ex.Message;
        }
        StateHasChanged();
    }

    private void OnHoverBuildableVertex(SettlersOfIdlestan.Model.HexGrid.Vertex v)
    {
        hoveredBuildableVertex = v;
        StateHasChanged();
    }

    private void OnLeaveBuildableVertex()
    {
        hoveredBuildableVertex = null;
        StateHasChanged();
    }

    private void OnClickBuildableVertex(SettlersOfIdlestan.Model.HexGrid.Vertex v)
    {
        try
        {
            Controller!.CityBuilderController.BuildCity(0, v);
            buildMessage = "Ville construite";
        }
        catch (Exception ex)
        {
            buildMessage = ex.Message;
        }
        StateHasChanged();
    }

    private void OnClickHex(HexCoord coord)
    {
        Logger?.LogInformation("Clicked hex at {coord}", coord);
        try
        {
            if (Map == null || Civilizations == null) return;
            // perform a manual harvest for player (index 0)
            var success = Controller!.HarvestController.ManualHarvest(0, coord);
            buildMessage = success ? "Récolte réussie" : "Récolte en cooldown ou impossible";
        }
        catch (Exception ex)
        {
            buildMessage = ex.Message;
        }
        StateHasChanged();
    }

    private async System.Threading.Tasks.Task CityClicked(SettlersOfIdlestan.Model.City.City city)
    {
        try
        {
            // toggle selection: if same as current selected, deselect
            if (SelectedCity != null && SelectedCity.Position.Equals(city.Position))
            {
                if (OnCitySelected.HasDelegate)
                    await OnCitySelected.InvokeAsync((SettlersOfIdlestan.Model.City.City?)null);
            }
            else
            {
                if (OnCitySelected.HasDelegate)
                    await OnCitySelected.InvokeAsync(city);
            }
        }
        catch
        {
            // ignore
        }
    }

    private async System.Threading.Tasks.Task OnMapBackgroundClick()
    {
        try
        {
            if (OnCitySelected.HasDelegate)
                await OnCitySelected.InvokeAsync((SettlersOfIdlestan.Model.City.City?)null);
        }
        catch { }
    }

    private void OnHoverCity(SettlersOfIdlestan.Model.City.City city)
    {
        hoveredCity = city;
        StateHasChanged();
    }

    private void OnLeaveCity()
    {
        hoveredCity = null;
        StateHasChanged();
    }
}

